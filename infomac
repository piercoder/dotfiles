#!/bin/sh
###############################################################################
# macos-sysinfo — Enhanced macOS System Information Script
#
# Description:
#   Displays detailed macOS system, hardware, and network information
#   in multiple output formats: ASCII art (colored), plain text, or JSON.
#   Includes CPU, RAM, disk, uptime, package counts, and network IP details.
#
# Features:
#   - POSIX-compliant (runs with /bin/sh)
#   - Colorized ASCII art output for TTYs with >=256 colors
#   - Plain text key=value mode for easy parsing
#   - JSON output with stable keys for scripting/automation
#   - Short mode for fast minimal output
#   - Detects Rosetta translation on Apple Silicon
#   - Accurate memory usage (excludes speculative pages)
#   - IPv6 shortening for display while preserving full value in plain/JSON
#   - Homebrew package counts with fast directory scan fallback
#
# Usage:
#   ./macos-sysinfo [options]
#
# Options:
#   -n, --no-color   Disable ANSI colors (or set NO_COLOR)
#   -p, --plain      Plain key=value output, no ASCII art
#   -s, --short      Fast plain output; implies --plain, skips brew counts
#   -j, --json       Emit JSON with stable keys
#   -h, --help       Show usage and exit
#   -v, --version    Show script version and exit
#
# Examples:
#   ./macos-sysinfo            # full color ASCII output (if supported)
#   ./macos-sysinfo --plain    # plain key=value output
#   ./macos-sysinfo --json     # JSON output for automation
#   ./macos-sysinfo --short    # minimal quick output
#
# Author:
#   Pierpaolo Pattitoni — https://github.com/piercoder
#
# License:
#   MIT License — https://opensource.org/licenses/MIT
#
# Warning:
#   This script is read-only: it does not change system settings.
#   However, it executes system commands that may vary in availability
#   and output format between macOS versions.
###############################################################################

set -eu
umask 022
PATH=/usr/bin:/bin:/usr/sbin:/sbin:/opt/homebrew/bin:/usr/local/bin
LC_ALL=C

SCRIPT_VERSION="1.1.0"

#========================#
#    Helpers
#========================#

# Convert bytes to GiB with one decimal place.
TO_GIB() { awk -v b="$1" 'BEGIN{printf("%.1f", b/1073741824)}'; }

# Print aligned "key=value" with a dynamic key width.
PRINT_KV() {
  key=$1; val=$2; width=$3
  printf "%-*s=%s\n" "$width" "$key" "$val"
}

# Escape a string for JSON context (basic subset: quotes, backslashes, tabs, CR/LF).
JSON_ESC() {
  s=$1
  s=$(printf %s "$s" | sed 's/\\/\\\\/g; s/\"/\\\"/g; s/\t/\\t/g; s/\r/\\r/g; s/\n/\\n/g')
  printf %s "$s"
}

# Shorten IPv6 specifically for the ASCII box: fixed max length (15 chars),
# central ellipsis, and strip any scope (e.g., "%en0"). Keeps full value in plain/JSON.
SHORTEN_IPV6_BOX() {
  s=$1
  [ -z "$s" ] && { printf %s ""; return; }
  [ "$s" = "Unavailable" ] && { printf %s "$s"; return; }
  s=${s%%\%*}
  maxlen=15
  len=$(printf %s "$s" | awk '{print length($0)}')
  if [ "$len" -le "$maxlen" ]; then
    printf %s "$s"
    return
  fi
  left=$(( (maxlen - 1) / 2 ))
  right=$(( maxlen - 1 - left ))
  lh=$(printf %s "$s" | awk -v n="$left" '{print substr($0,1,n)}')
  rh=$(printf %s "$s" | awk -v n="$right" -v L="$len" '{print substr($0,L-n+1,n)}')
  printf '%s…%s' "$lh" "$rh"
}

#========================#
#        Args
#========================#
COLOR=1 PLAIN=0 SHORT=0 JSON=0
for arg in "$@"; do
  case "$arg" in
    -n|--no-color) COLOR=0 ;;
    -p|--plain)    PLAIN=1 ;;
    -s|--short)    SHORT=1; PLAIN=1 ;;
    -j|--json)     JSON=1; PLAIN=1 ;;
    -h|--help)
      printf 'Usage: %s [--no-color|-n] [--plain|-p] [--short|-s] [--json|-j] [--version|-v]\n' "${0##*/}"
      exit 0
      ;;
    -v|--version)
      printf '%s\n' "$SCRIPT_VERSION"
      exit 0
      ;;
  esac
done

#========================#
#      Color gating
#========================#
# Enable color only when: stdout is a TTY, NO_COLOR is unset, color not disabled,
# and output mode is not plain. Require truecolor or >=256-color support.
colors_ok=0
if [ -t 1 ] && [ "${NO_COLOR:-}" = "" ] && [ "$COLOR" -eq 1 ] && [ "$PLAIN" -eq 0 ]; then
  if [ "${COLORTERM:-}" = "truecolor" ]; then
    colors_ok=1
  else
    if command -v tput >/dev/null 2>&1; then
      if [ "$(tput colors 2>/dev/null || echo 0)" -ge 256 ]; then
        colors_ok=1
      fi
    fi
  fi
fi

if [ "$colors_ok" -eq 1 ]; then
  ESC=$(printf '\033')
  ACCENT1="${ESC}[38;2;232;51;28m"      # red
  ACCENT2="${ESC}[38;2;104;193;86m"     # green
  ACCENT3="${ESC}[38;2;241;211;43m"     # yellow
  ACCENT4="${ESC}[38;2;28;152;232m"     # blue
  NC="${ESC}[0m"                        # reset
  BOLD="${ESC}[1m"                      # bold
else
  ACCENT1=""; ACCENT2=""; ACCENT3=""; ACCENT4=""
  NC=""; BOLD=""
fi

#========================#
#      macOS check
#========================#
# Exit early on non-Darwin systems to avoid calling macOS tools.
[ "$(uname -s 2>/dev/null || echo unknown)" = "Darwin" ] || {
  printf '%s\n' "This script is intended for macOS (Darwin). Exiting." >&2
  exit 1
}

#========================#
#    System Information
#========================#
USER_INFO="$(whoami)@$(hostname -s 2>/dev/null || hostname)"
OS_NAME=$(sw_vers -productName 2>/dev/null || echo "macOS")
OS_VER=$(sw_vers -productVersion 2>/dev/null || echo "?")
OS="$OS_NAME $OS_VER"
KERNEL="$(uname -sr)"
ARCH=$(uname -m 2>/dev/null || echo "?")

# Force LC_ALL=C on parsed commands for stable parsing.
if LC_ALL=C uptime -p >/dev/null 2>&1; then
  UPTIME=$(LC_ALL=C uptime -p | sed 's/^up //')
else
  # Fallback for older macOS: strip everything except the "up ..." chunk.
  UPTIME=$(LC_ALL=C uptime | sed 's/^.*up *//; s/,.*//' | tr -s ' ')
fi

#========================#
#     Hardware Info
#========================#
CPU_BRAND=$(sysctl -n machdep.cpu.brand_string 2>/dev/null || true)
[ -n "$CPU_BRAND" ] || CPU_BRAND=$(sysctl -n hw.model 2>/dev/null || echo "?")
CPU_LOGICAL=$(sysctl -n hw.ncpu 2>/dev/null || echo "?")
CPU_PHYSICAL=$(sysctl -n hw.physicalcpu 2>/dev/null || echo "?")
ROSETTA=$(sysctl -n sysctl.proc_translated 2>/dev/null || echo 0)
[ "$ROSETTA" = "1" ] && CPU_BRAND="$CPU_BRAND (Rosetta)"
CPU="$CPU_BRAND (${CPU_PHYSICAL}c/${CPU_LOGICAL}t, $ARCH)"

#========================#
#      Memory (vm_stat)
#========================#
# Use hw.pagesize and vm_stat counters.
# "Used" excludes speculative pages; the compressor is shown separately.
PAGE_SIZE=$(sysctl -n hw.pagesize 2>/dev/null || echo 4096)
VM_OUT=$(LC_ALL=C vm_stat 2>/dev/null || true)
# Parse vm_stat with tolerant patterns; read the final numeric field on each line.
set -- $(printf '%s\n' "$VM_OUT" | awk '
  /Pages active/            {gsub(/\./,""); a=$NF+0}
  /Pages wired/             {gsub(/\./,""); w=$NF+0}
  /Pages speculative/       {gsub(/\./,""); s=$NF+0}
  /Pages occupied by/       {gsub(/\./,""); c=$NF+0}
  END{print a+0, w+0, s+0, c+0}
')
ACTIVE=${1:-0} WIRED=${2:-0} SPEC=${3:-0} COMPRESS=${4:-0}

TOTAL_BYTES=$(sysctl -n hw.memsize 2>/dev/null || echo 0)
USED_BYTES=$(( (ACTIVE + WIRED) * PAGE_SIZE ))     # exclude speculative
COMPRESS_BYTES=$(( COMPRESS * PAGE_SIZE ))         # compressed store size
MEM_USED_GIB=$(TO_GIB "$USED_BYTES")
MEM_TOTAL_GIB=$(TO_GIB "$TOTAL_BYTES")
MEM_PCT=$(awk -v u="$USED_BYTES" -v t="$TOTAL_BYTES" 'BEGIN{printf("%.0f", (t?u*100/t:0))}')
MEMORY="${MEM_USED_GIB} / ${MEM_TOTAL_GIB} GiB (${MEM_PCT}%)  [cmp: $(TO_GIB "$COMPRESS_BYTES") GiB]"

# Shorter variant for the ASCII box (no compressor, integers only).
MEMORY_BOX="${MEM_USED_GIB%.*} / ${MEM_TOTAL_GIB%.*} GiB (${MEM_PCT}%)"

#========================#
#      Disk usage
#========================#
# Prefer the Data volume on APFS; fall back to root if not present.
TARGET="/System/Volumes/Data"; [ -d "$TARGET" ] || TARGET="/"
read -r DISK_USED_KB DISK_TOTAL_KB DISK_PERC <<EOF
$(LC_ALL=C df -kP "$TARGET" | awk 'NR==2{print $3, $2, $5}')
EOF
DISK_VALUE=$(awk -v u="$DISK_USED_KB" -v t="$DISK_TOTAL_KB" -v p="$DISK_PERC" \
  'BEGIN{printf("%.1f / %.1f GiB (%s)", u/1048576, t/1048576, p)}')

#========================#
#     Packages (brew)
#========================#
# When not in --short mode and brew exists, estimate counts cheaply by listing
# directories in the Cellar/Caskroom; fall back to "brew list" if unavailable.
BREW_PACKAGES=0 CASK_PACKAGES=0
if [ "$SHORT" -eq 0 ] && command -v brew >/dev/null 2>&1; then
  CELLAR=$(brew --cellar 2>/dev/null || echo "")
  CASKROOM=$(brew --caskroom 2>/dev/null || echo "")
  if [ -n "$CELLAR" ] && [ -d "$CELLAR" ]; then
    BREW_PACKAGES=$(find "$CELLAR" -mindepth 1 -maxdepth 1 -type d -prune 2>/dev/null | wc -l | tr -d ' ')
  else
    BREW_PACKAGES=$(brew list -1 2>/dev/null | wc -l | tr -d ' ')
  fi
  if [ -n "$CASKROOM" ] && [ -d "$CASKROOM" ]; then
    CASK_PACKAGES=$(find "$CASKROOM" -mindepth 1 -maxdepth 1 -type d -prune 2>/dev/null | wc -l | tr -d ' ')
  else
    CASK_PACKAGES=$(brew list --cask -1 2>/dev/null | wc -l | tr -d ' ')
  fi
fi

#========================#
#     Network Info
#========================#
# Determine the active interface from the default route. Fallback to common Wi-Fi interfaces.
IFACE=$(LC_ALL=C route -n get default 2>/dev/null | awk '/interface:/{print $2}')
[ -n "${IFACE:-}" ] || IFACE=$( (ipconfig getifaddr en0 >/dev/null 2>&1 && echo en0) || \
                                 (ipconfig getifaddr en1 >/dev/null 2>&1 && echo en1) || echo "")
# IPv4
if [ -n "$IFACE" ]; then
  IP4=$(ipconfig getifaddr "$IFACE" 2>/dev/null || true)
else
  IP4=""
fi
[ -n "${IP4:-}" ] || IP4="Unavailable"

# IPv6: prefer temporary global; otherwise first global. Exclude link-local and ::1.
IP6="Unavailable"
if [ -n "$IFACE" ]; then
  if LC_ALL=C ifconfig "$IFACE" >/dev/null 2>&1; then
    IP6_TMP=$(LC_ALL=C ifconfig "$IFACE" 2>/dev/null | awk '/inet6 / && /temporary/ {print $2}' | awk '!/^fe80:/ && !/%/')
    if [ -n "${IP6_TMP:-}" ]; then
      IP6=$(printf '%s\n' "$IP6_TMP" | awk 'NR==1{print; exit}')
    else
      IP6_CAND=$(LC_ALL=C ifconfig "$IFACE" 2>/dev/null | awk '/inet6 /{print $2}' | awk '!/^fe80:/ && !/%/')
      if [ -n "${IP6_CAND:-}" ]; then
        IP6=$(printf '%s\n' "$IP6_CAND" | awk 'NR==1{print; exit}')
      fi
    fi
  fi
fi
[ "$IP6" = "::1" ] && IP6="Unavailable"
IP6_BOX=$(SHORTEN_IPV6_BOX "$IP6")

#========================#
#       Output modes
#========================#
if [ "$JSON" -eq 1 ]; then
  # Emit a single-line JSON object (mostly strings; sizes are numeric).
  printf '{'
  printf '"version":"%s"' "$(JSON_ESC "$SCRIPT_VERSION")"
  printf ',"user":"%s"'   "$(JSON_ESC "$USER_INFO")"
  printf ',"os_name":"%s","os_version":"%s","os":"%s"' \
         "$(JSON_ESC "$OS_NAME")" "$(JSON_ESC "$OS_VER")" "$(JSON_ESC "$OS")"
  printf ',"kernel":"%s","arch":"%s"' "$(JSON_ESC "$KERNEL")" "$(JSON_ESC "$ARCH")"
  printf ',"cpu_brand":"%s","cpu_physical":%s,"cpu_logical":%s,"rosetta":%s' \
         "$(JSON_ESC "$CPU_BRAND")" "$(printf %s "$CPU_PHYSICAL")" "$(printf %s "$CPU_LOGICAL")" "$(printf %s "$ROSETTA")"
  printf ',"cpu":"%s"' "$(JSON_ESC "$CPU")"
  printf ',"uptime":"%s"' "$(JSON_ESC "$UPTIME")"
  printf ',"mem_total_bytes":%s,"mem_used_bytes_excl_speculative":%s,"mem_compressor_bytes":%s' \
         "$(printf %s "$TOTAL_BYTES")" "$(printf %s "$USED_BYTES")" "$(printf %s "$COMPRESS_BYTES")"
  printf ',"mem_total_gib":"%s","mem_used_gib":"%s","mem_percent":%s' \
         "$MEM_TOTAL_GIB" "$MEM_USED_GIB" "$MEM_PCT"
  printf ',"disk_used_kb":%s,"disk_total_kb":%s,"disk_percent":"%s","disk":"%s"' \
         "$(printf %s "$DISK_USED_KB")" "$(printf %s "$DISK_TOTAL_KB")" "$(JSON_ESC "$DISK_PERC")" "$(JSON_ESC "$DISK_VALUE")"
  printf ',"brew_packages":%s,"cask_packages":%s' \
         "$(printf %s "$BREW_PACKAGES")" "$(printf %s "$CASK_PACKAGES")"
  printf ',"iface":"%s","ip4":"%s","ip6":"%s"' \
         "$(JSON_ESC "$IFACE")" "$(JSON_ESC "$IP4")" "$(JSON_ESC "$IP6")"
  printf '}'
  printf '\n'
  exit 0
fi

if [ "$PLAIN" -eq 1 ]; then
  # Plain key=value output. Compute max key width for neat alignment.
  KEY_WIDTH=0
  if [ "$SHORT" -eq 1 ]; then
    for k in user os kernel uptime cpu ram disk ip4 ip6; do
      len=${#k}; [ "$len" -gt "$KEY_WIDTH" ] && KEY_WIDTH=$len
    done
    PRINT_KV user   "$USER_INFO" "$KEY_WIDTH"
    PRINT_KV os     "$OS"        "$KEY_WIDTH"
    PRINT_KV kernel "$KERNEL"    "$KEY_WIDTH"
    PRINT_KV uptime "$UPTIME"    "$KEY_WIDTH"
    PRINT_KV cpu    "$CPU"       "$KEY_WIDTH"
    PRINT_KV ram    "$MEMORY"    "$KEY_WIDTH"
    PRINT_KV disk   "$DISK_VALUE" "$KEY_WIDTH"
    PRINT_KV ip4    "$IP4"       "$KEY_WIDTH"
    PRINT_KV ip6    "$IP6"       "$KEY_WIDTH"   # full IPv6 in plain/short
  else
    for k in user os kernel uptime brew cask cpu ram disk ip4 ip6; do
      len=${#k}; [ "$len" -gt "$KEY_WIDTH" ] && KEY_WIDTH=$len
    done
    PRINT_KV user   "$USER_INFO"     "$KEY_WIDTH"
    PRINT_KV os     "$OS"            "$KEY_WIDTH"
    PRINT_KV kernel "$KERNEL"        "$KEY_WIDTH"
    PRINT_KV uptime "$UPTIME"        "$KEY_WIDTH"
    PRINT_KV brew   "$BREW_PACKAGES" "$KEY_WIDTH"
    PRINT_KV cask   "$CASK_PACKAGES" "$KEY_WIDTH"
    PRINT_KV cpu    "$CPU"           "$KEY_WIDTH"
    PRINT_KV ram    "$MEMORY"        "$KEY_WIDTH"
    PRINT_KV disk   "$DISK_VALUE"    "$KEY_WIDTH"
    PRINT_KV ip4    "$IP4"           "$KEY_WIDTH"
    PRINT_KV ip6    "$IP6"           "$KEY_WIDTH"   # full IPv6 in plain
  fi
  exit 0
fi

#========================#
#   ASCII art (colored)
#========================#
printf "\n"
printf "                     %s..'%s          %s%s┌──────────── System ────────────┐%s\n" "$ACCENT4" "$NC" "$BOLD" "$ACCENT4" "$NC"
printf "                 %s,xNMM.%s           %s│%s %sUser:%s %s\n" "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT1" "$NC" "$USER_INFO"
printf "               %s.OMMMMo%s            %s│%s %sOS:%s %s\n" "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT1" "$NC" "$OS"
printf "               %slMM\"%s               %s│%s %sKernel:%s %s\n" "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT1" "$NC" "$KERNEL"
printf "     %s.;loddo:.  .olloddol;.%s       %s│%s %sUptime:%s %s\n" "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT1" "$NC" "$UPTIME"
printf "   %scKMMMMMMMMMMNWMMMMMMMMMM0:%s     %s│%s %sPackages:%s %s (brew), %s (cask)\n" "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT1" "$NC" "$BREW_PACKAGES" "$CASK_PACKAGES"
printf " .%sKMMMMMMMMMMMMMMMMMMMMMMMWd.%s     %s%s└────────────────────────────────┘%s\n" "$ACCENT4" "$NC" "$BOLD" "$ACCENT4" "$NC"

printf " %sXMMMMMMMMMMMMMMMMMMMMMMMX.%s       %s%s┌─────────── Hardware ───────────┐%s\n" "$ACCENT4" "$NC" "$BOLD" "$ACCENT4" "$NC"
printf "%s;MMMMMMMMMMMMMMMMMMMMMMMM:%s        %s│%s %sCPU:%s %s\n" "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT2" "$NC" "$CPU"
printf "%s:MMMMMMMMMMMMMMMMMMMMMMMM:%s        %s│%s %sRAM:%s %s\n" "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT2" "$NC" "$MEMORY_BOX"
printf "%s.MMMMMMMMMMMMMMMMMMMMMMMX.%s        %s│%s %sDisk:%s %s\n" "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT2" "$NC" "$DISK_VALUE"
printf " %skMMMMMMMMMMMMMMMMMMMMMMMMWd.%s     %s%s└────────────────────────────────┘%s\n" "$ACCENT4" "$NC" "$BOLD" "$ACCENT4" "$NC"

printf " %s'XMMMMMMMMMMMMMMMMMMMMMMMMMMk%s    %s%s┌─────────── Network ────────────┐%s\n" "$ACCENT4" "$NC" "$BOLD" "$ACCENT4" "$NC"
printf "  %s'XMMMMMMMMMMMMMMMMMMMMMMMMK.%s    %s│%s %sIPv4:%s %s\n" "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT3" "$NC" "$IP4"
printf "    %skMMMMMMMMMMMMMMMMMMMMMMd%s      %s│%s %sIPv6:%s %s\n" \
  "$ACCENT4" "$NC" "$ACCENT4" "$NC" "$BOLD$ACCENT3" "$NC" "$IP6_BOX"
printf "     %s;KMMMMMMMWXXWMMMMMMMk.%s       %s%s└────────────────────────────────┘%s\n" "$ACCENT4" "$NC" "$BOLD" "$ACCENT4" "$NC"

printf "       %s\"cooc*\"    \"*coo'\"%s         \n\n" "$ACCENT4" "$NC"